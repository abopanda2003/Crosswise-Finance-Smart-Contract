import { assert, expect } from "chai";

import hre, { deployments, ethers, waffle } from "hardhat";
import { BigNumber } from "ethers";
import "@nomiclabs/hardhat-ethers";

import { CrossFactory } from "../types/CrossFactory";
import { CrossRouter } from "../types/CrossRouter";
import { CrssToken } from "../types/CrssToken";
import { WBNB as WBNBT } from "../types/WBNB";
import { MockTransfer } from "../types/MockTransfer";
import { XCrssToken } from "../types/XCrssToken";
import { MockToken } from "../types/MockToken";

describe("\t\t \tCrssToken test report generated by automated testing script\n", async () => {
  const [owner, userA, userB, userC, devTo, buybackTo] =
    waffle.provider.getWallets();

  const setupTest = deployments.createFixture(async ({ deployments }) => {
    await deployments.fixture();

    const Factory = await hre.ethers.getContractFactory("CrossFactory");
    const factory = (await Factory.deploy(owner.address)) as CrossFactory;
    await factory.deployed();

    const WBNB = await hre.ethers.getContractFactory("WBNB");
    const wbnb = (await WBNB.deploy()) as WBNBT;
    await wbnb.deployed();

    const Router = await hre.ethers.getContractFactory("CrossRouter");
    const router = (await Router.deploy(
      factory.address,
      wbnb.address
    )) as CrossRouter;
    await router.deployed();

    await factory.setRouter(router.address);

    const liquifyThreshold = hre.ethers.utils.parseEther("100000");

    const Crss = await hre.ethers.getContractFactory("CrssToken");
    const crss = (await hre.upgrades.deployProxy(Crss, [
      router.address,
      devTo.address,
      buybackTo.address,
      liquifyThreshold,
    ])) as CrssToken;
    await crss.deployed();

    await router.setCrssContract(crss.address);

    const XCrss = await hre.ethers.getContractFactory("xCrssToken");
    const xCrss = (await hre.upgrades.deployProxy(XCrss, [
      crss.address,
    ])) as XCrssToken;
    await xCrss.deployed();

    const MockTransfer = await hre.ethers.getContractFactory("MockTransfer");
    const mockTransfer = (await MockTransfer.deploy(
      crss.address
    )) as MockTransfer;
    await mockTransfer.deployed();

    return {
      factory,
      router,
      crss,
      wbnb,
      xCrss,
      mockTransfer,
    };
  });

  let factory: CrossFactory,
    router: CrossRouter,
    crss: CrssToken,
    wbnb: WBNBT,
    xCrss: XCrssToken,
    mockTransfer: MockTransfer;

  let farm: any;

  before("load fixture loader", async () => {
    ({ factory, router, crss, wbnb, xCrss, mockTransfer } = await setupTest());

    farm = {
      address: owner.address,
    };
  });

  describe("\t1. Deployment test", async function () {
    it("Deployed CRSS token should have correct name and symbol and decimal.\n", async function () {
      const name = await crss.name();
      const symbol = await crss.symbol();
      const decimals = await crss.decimals();

      console.log("\t\t CRSS token's name should be Crosswise Token.");
      expect(name, "Crosswise Token");
      console.log("\t\t CRSS symbol should be CRSS.");
      expect(symbol, "CRSS");
      console.log("\t\t CRSS decimals should be 18.");
      expect(decimals, "18");
    });
  });

  describe("\t2. Traransfer test", async function () {
    before(async function () {
      await crss.connect(owner).setFarm(owner.address);
    });

    after(async function () {
      await crss.connect(owner).setFarm(farm.address);
    });

    // Burn all tokens each accounts have before each tests.
    beforeEach("burn all tokens before each test cases.", async function () {
      await crss
        .connect(owner)
        .burn(crss.address, await crss.balanceOf(crss.address));
      await crss
        .connect(owner)
        .burn(owner.address, await crss.balanceOf(owner.address));
      await crss
        .connect(owner)
        .burn(userA.address, await crss.balanceOf(userA.address));
      await crss
        .connect(owner)
        .burn(userB.address, await crss.balanceOf(userB.address));
      await crss
        .connect(owner)
        .burn(userC.address, await crss.balanceOf(userC.address));
      await crss
        .connect(owner)
        .burn(devTo.address, await crss.balanceOf(devTo.address));
      await crss
        .connect(owner)
        .burn(buybackTo.address, await crss.balanceOf(buybackTo.address));
      await crss
        .connect(owner)
        .burn(mockTransfer.address, await crss.balanceOf(mockTransfer.address));
    });

    it("Should supply token transfers properly\n", async function () {
      console.log("\t - It should supply basic token transfers properly.");
      /*
        Scenario:
        1. Owner mint some amounts for userA and userB.
        2. Total supply amount should be sum of userA and userB's balance.
        3. userA and userB send some amounts to userC and transfer amounts are not exceeding max transfer amount.
        4. userA and userB's balances will be reduced as amounts they sent to userC. And userC's balance should be sum of transferred amounts userA and userB sent.
      */

      console.log(
        "\t\t Total Supply before minting is ",
        (await crss.totalSupply()).toNumber()
      );

      // Scenario 1.
      console.log("\t\t Owner is minting 10000 tokens to userA.");
      await crss.connect(owner).mint(userA.address, "10000");
      console.log("\t\t Owner is minting 10000 tokens to userB.\n");
      await crss.connect(owner).mint(userB.address, "10000");

      // Scenario 2.
      const totalSupply = await crss.totalSupply();
      console.log("\t\t TotalSupply should be 20000 tokens after minting.\n");
      expect(totalSupply).to.be.equal("20000");

      // Scenario 3.
      console.log("\t\t userA is transfering 5 tokens to userC.");
      await crss.connect(userA).transfer(userC.address, "5");
      console.log("\t\t userB is transfering 5 tokens to userC.\n");
      await crss.connect(userB).transfer(userC.address, "5");

      const userABal = await crss.balanceOf(userA.address);
      const userBBal = await crss.balanceOf(userB.address);
      const userCBal = await crss.balanceOf(userC.address);

      // Scenario 4.
      console.log("\t\t userA's balance should be 9995 after transfering.");
      expect(userABal).to.be.equal("9995");
      console.log("\t\t userB's balance should be 9995 after transfering.");
      expect(userBBal).to.be.equal("9995");
      console.log(
        "\t\t userC's balance should be 10 once got tranfer from A and B."
      );
      expect(userCBal).to.be.equal("10");
    });

    it("Should fail if you try to do bad transfers", async function () {
      console.log("\t - It should fail if you try to do bad transfers.");
      /*
        Scenario:
        Bad transfer means transferring over amount of maxTransferAmount and current account balance for this test.
        1. Owner mint some amounts for userA.
        2. userA shouldn't be able to send amount is exceeding maxTransferAmount after changing total supply amount from minting.
        3. userA shouldn't be able to send amount is exceeding his balance.
      */

      //  Scenario 1.
      console.log("\t\t Owner is minting 10000 tokens to userA.");
      await crss.connect(owner).mint(userA.address, "10000");

      // Scenario 2.
      console.log(
        "\t\t userA shouldn't be able to transfer amount is exceeding max transfer amount.\n"
      );
      await expect(
        crss.connect(userA).transfer(userB.address, 1000)
      ).to.be.revertedWith("CrssToken: Exceed MaxTransferAmount");

      // Scenario 3.
      console.log("\t\t Owner is minting 1 CRSS token to userB");
      await crss.connect(owner).mint(userB.address, "1");
      console.log(
        "\t\t userB shouldn't be able to transfer amount is exceeding his balance."
      );
      await expect(
        crss.connect(userB).transfer(userB.address, "2")
      ).to.be.revertedWith("ERC20: transfer amount exceeds balance");
    });
  });
});
